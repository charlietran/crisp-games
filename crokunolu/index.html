<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>crokunolu</title>
    <meta name="viewport" content="width=device-width, height=device-height,
    user-scalable=no, initial-scale=1, maximum-scale=1" />
    <script src="https://unpkg.com/sounds-some-sounds@3.0.0/build/index.js"></script>
    <script src="https://unpkg.com/gif-capture-canvas@1.1.0/build/index.js"></script>
    <script src="https://unpkg.com/pixi.js@5.3.0/dist/pixi.min.js"></script>
    <script src="https://unpkg.com/pixi-filters@3.1.1/dist/pixi-filters.js"></script>
    <script src="https://unpkg.com/crisp-game-lib@1.1.1/docs/bundle.js"></script>

    <script>
        setupGame();

        let shooter;
        let shooterMoving;
        let discs;
        let discsLeft;
        const states = {
            IDLE: 0,
            SHOOTING: 1,
            JUST_SHOT: 2,
            POWERING: 3,
            MOVING: 4,
        };
        const friction = 0.98;

        const board = {
            x: 49,
            y: 50,
            y_offset: 0,
            radius: 48,
            board_thickness: 3,
            peg_thickness: 2,
        }

        const maxDiscs = 8;

        const isShapeTheme = options.theme == "shape" || options.theme == "shapeDark";


        function initializeGame() {
            document.title = "CROKUNOLU";
            shooter = {
                base_pos: vec(49, 86),
                pos: vec(49, 86),
                prevPos: vec(),
                vel: vec(),
                angle: 0,
                angleVel: -1,
                power: 1,
                basePower: 1,
                prevBasePower: 1,
                state: states.IDLE,
            };
            board.pos = vec(board.x, board.y + board.y_offset);
            board.pegs = [
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (1 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (3 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (5 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (7 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (9 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (11 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (13 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (15 / 8), board.radius / 3),
            ];

            if (isShapeTheme) {
                board.dividerLineThickness = 0.5;
            } else {
                board.dividerLineThickness = 1;
            }


            discs = [];
            discsLeft = 8;
            shooterMoving = false;
        }

        function update() {
            if (!ticks) {
                initializeGame();
            }

            drawBoard();
            drawDiscCount();

            if (shooter.state == states.IDLE && input.isJustPressed) {
                shooter.state = states.SHOOTING;
                setShooterPos();
            }

            if (shooter.state == states.SHOOTING) {
                updateShooting();
            }

            if (shooter.state == states.SHOOTING) {
                drawShooter();
            }

            updateDiscs();
            updatePegs();
            checkEnd();
        }

        function checkEnd() {
            if (discsLeft < 1 && !shooterMoving) {
                end();
            }
        }

        function drawDiscCount() {
            color("black");
            times(discsLeft, (i) => {
                char("a", 2 + i * 6, options.viewSize.y - 3)
            });

        }

        function drawBoard() {
            color("light_black");

            // draw outer ring
            arc(
                board.pos.x, // x
                board.pos.y, // y
                board.radius, // radius
                board.board_thickness, // thickness
                // Math.PI, // from ang
                // 2 * Math.PI, // to ang
            );

            // draw inner ring
            arc(
                board.pos.x, // x
                board.pos.y, // y
                board.radius * 2 / 3, // radius
                board.dividerLineThickness, // thickness
                // Math.PI, // from ang
                // 2 * Math.PI, // to ang
            );

            // draw divider lines
            line(board.pos.x + 4, board.pos.y, board.pos.x + board.radius, board.pos.y, board.dividerLineThickness);
            line(board.pos.x - 4, board.pos.y, board.pos.x - board.radius, board.pos.y, board.dividerLineThickness);
            line(board.pos.x, board.pos.y + 4, board.pos.x, board.pos.y + board.radius, board.dividerLineThickness);
            line(board.pos.x, board.pos.y - 4, board.pos.x, board.pos.y - board.radius, board.dividerLineThickness);

            // draw center hole
            color("light_blue");
            if (isShapeTheme) {
                arc(board.pos, 4, 0.5);
            } else {
                // box(board.pos.x, board.pos.y, 3);
                char("c", board.pos.x - 1, board.pos.y - 1);
            }
        }

        function updatePegs() {
            color("black");
            board.pegs.forEach(p => {
                // char("c", p);
                rect(p, 2);
                // arc(p, .75, .75);
            });
        }

        function drawShooter() {
            color("black");
            char("a", shooter.pos);
            // box(shooter, 3);
        }

        const shooterRadius = 42;

        function setShooterPos() {
            const angle = input.pos.angleTo(board.pos);
            let newPos = vec(board.pos).addWithAngle(angle, -shooterRadius);
            // newPos.x = clamp(newPos.x, board.pos.x - shooterRadius, board.pos.x + shooterRadius);
            newPos.y = clamp(newPos.y, board.pos.y + 2, newPos.y);
            shooter.pos = newPos;
        }

        function updateShooting() {
            // shooter.angle += shooter.angleVel * 0.05;
            shooter.angle = input.pos.angleTo(shooter.pos);
            shooter.power = clamp(input.pos.distanceTo(shooter.pos) / 5 + 0.5, 0.5, 6);
            //     -PI / 2 - PI / 3,
            //     -PI / 2 + PI / 3,
            // );
            // if (
            //     (shooter.angle < -PI && shooter.angleVel < 0) ||
            //     (shooter.angle > 0 && shooter.angleVel > 0)
            // ) {
            //     shooter.angleVel = -shooter.angleVel;
            //     shooter.angle += shooter.angleVel * 0.05 * 2;
            // }
            color("light_yellow");
            bar(shooter.pos.x + .5, shooter.pos.y, shooter.power * 5, 1, shooter.angle, 0);

            if (input.isJustReleased) {
                shooter.state = states.JUST_SHOT;
                play("jump");
                discs.push({
                    pos: vec(shooter.pos.x, shooter.pos.y),
                    prevPos: vec(shooter.pos.x, shooter.pos.y),
                    vel: vec(shooter.vel.x, shooter.vel.y).addWithAngle(shooter.angle, shooter.power * 0.5 * shooter.basePower),
                    state: states.MOVING,
                    just_shot: true,
                });
                discsLeft -= 1;
                shooterMoving = true;
            }
            // line(vec(shooter.pos.x + 1, shooter.pos.y + 1), vec(shooter.pos).addWithAngle(shooter.angle, 12), 1);
        }

        function resetShooter() {
            shooter.pos = shooter.base_pos;
            shooter.state = states.IDLE;
            shooterMoving = false;
        }

        function updateDiscs() {
            color("black");

            remove(discs, (d) => {
                if (d.removeTimer === 0) {
                    return true;
                } else if (d.removeTimer > 0) {
                    d.removeTimer -= 1;
                    if (d.removeTimer % 6 == 0 || d.removeTimer % 7 == 0 || d.removeTimer % 9 == 0) {
                        char("b", d.pos);
                    } else {
                        char("a", d.pos);
                    }
                    return;
                }

                // check if out of bounds
                if (d.pos.distanceTo(board.pos) > (board.radius - 1)) {
                    if (d.just_shot) {
                        d.just_shot = false;
                        resetShooter();
                    }
                    play("synth");
                    d.removeTimer = 30;
                }

                // check if in the hole
                if (d.pos.distanceTo(board.pos) < 2 && d.vel.length < 0.3) {
                    play("coin");
                    addScore(20, board.pos);
                    discsLeft = clamp(discsLeft, discsLeft + 1, maxDiscs);
                    if (d.just_shot) {
                        resetShooter();
                    }
                    return true;
                }


                char("a", d.pos);

                if (d.vel.length < 0.1) {
                    d.vel = vec(0, 0);
                    d.state = states.IDLE;
                    if (d.just_shot) {
                        d.just_shot = false;
                        resetShooter();
                    }
                } else {
                    // move steps based on velocity
                    let xsteps = abs(d.vel.x);
                    let ysteps = abs(d.vel.y);
                    for (i = 0; i < xsteps; i++) {
                        step = floor(i, 1) * Math.sign(d.vel.x);
                    }
                    d.pos.add(d.vel);
                    d.vel.mul(friction);

                    // console.log(d.vel);
                    // check collisions with pegs
                    board.pegs.forEach((p) => {
                        const checkVec = vec(d.pos);
                        if (checkVec.distanceTo(p) < 4) {
                            checkPegCollide(d, p);
                        }
                    });

                    if (d.state == states.MOVING) {
                        // check collisions with other discs
                        discs.forEach((cd) => {
                            if (d == cd) {
                                return;
                            }

                            if (d.pos.distanceTo(cd.pos) < 4) {
                                const v = vec(d.vel);
                                setCollidingDiscVel(d, cd, v);
                                cd.state = states.MOVING;
                                play("hit");
                            }
                        });
                    }
                }

                d.prevPos = vec(d.pos);

            })
        }

        function checkPegCollide(d, p) {
            let hit = false;
            if (d.prevPos.distanceTo(p) < d.pos.distanceTo(p)) {
                return
            }
            if (abs(p.x - d.pos.x) < 1 && d.vel.y < 0 && p.y < d.pos.y || d.vel.y > 0 && p.y > d.pos.y) {
                d.vel.y *= -1
                hit = true;
            }
            if (abs(p.y - d.pos.y) < 1 && d.vel.x < 0 && p.x < d.pos.x || d.vel.x > 0 && p.x > d.pos.x) {
                d.vel.x *= -1
                hit = true;
            }
            if (hit) {
                play("hit");
            }
        }

        function setCollidingDiscVel(d1, d2) {
            // get the angle between the two discs
            const angleBetweenDiscs = d1.pos.angleTo(d2.pos);

            const d1vl = d1.vel.length;
            const d2vl = d2.vel.length;

            // proportion that velocity is lowered based on delta of velocity angle and discs angle
            const pr = abs(cos(d1.vel.angle - angleBetweenDiscs)) * 0.9;

            // remove proportional d1 velocity from d1
            d1.vel.addWithAngle(angleBetweenDiscs, -d1vl * pr);

            // add proportional d1 velocity to d2
            d2.vel.addWithAngle(angleBetweenDiscs, d1vl * pr);

            // remove proportional d2 velocity from d2
            d2.vel.addWithAngle(angleBetweenDiscs, -d2vl * pr);

            // add proportional d2 velocity to d2
            d1.vel.addWithAngle(angleBetweenDiscs, d2vl * pr);

        }

        function setupGame() {
            title = "CROKUNOLU";

            description = `[Slide]
 Aim/Power

[Release]
 Shoot`;

            characters = [
                `
 yyy
yYYYy
yYYYy
yYYYy
 yyy
`,
                `
 ppp
ppppp
ppppp
ppppp
 ppp
`,
                `
 BBB
B   B
B   B
B   B
 BBB
`,
            ];
            options = {
                isPlayingBgm: true,
                isReplayEnabled: true,
                seed: 2002,
                theme: "shape",
                viewSize: { x: 100, y: 116 }
                // theme: "shapeDark",
                // theme: "dark",
                // theme: "crt",
            };


            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('theme')) {
                options.theme = urlParams.get('theme');
            }
            if (urlParams.has('seed')) {
                options.seed = Number(urlParams.get('seed'));
            }
        }

        addEventListener("load", onLoad);
    </script>
</head>

<body style="background: #ddd"></body>

</html>