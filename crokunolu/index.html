<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>crokunolu</title>
    <meta name="viewport" content="width=device-width, height=device-height,
    user-scalable=no, initial-scale=1, maximum-scale=1" />
    <script src="https://unpkg.com/sounds-some-sounds@3.0.0/build/index.js"></script>
    <script src="https://unpkg.com/gif-capture-canvas@1.1.0/build/index.js"></script>
    <script src="https://unpkg.com/pixi.js@5.3.0/dist/pixi.min.js"></script>
    <script src="https://unpkg.com/pixi-filters@3.1.1/dist/pixi-filters.js"></script>
    <script src="https://unpkg.com/crisp-game-lib@1.1.1/docs/bundle.js"></script>

    <script>
        title = "CROKUNOLU";

        description = `[Slide]
 Aim/Power

[Release]
 Shoot`;

        characters = [
            `
 yyy
yYYYy
yYYYy
yYYYy
 yyy
`,
            `
 LLL
L   L
L   L
L   L
 LLL
`,
        ];
        options = {
            isPlayingBgm: true,
            isReplayEnabled: true,
            seed: 2002,
            theme: "shape",
        };

        let shooter;
        let discs;
        const states = {
            IDLE: 0,
            SHOOTING: 1,
            JUST_SHOT: 2,
            POWERING: 3,
            MOVING: 4,
        };
        const friction = 0.98;

        const board = {
            x: 50,
            y: 50,
            y_offset: 0,
            radius: 48,
            board_thickness: 3,
            peg_thickness: 2,
        }

        function initializeGame() {
            document.title = "CROKUNOLU";
            shooter = {
                base_pos: vec(49, 86),
                pos: vec(49, 86),
                prevPos: vec(),
                vel: vec(),
                angle: 0,
                angleVel: -1,
                power: 1,
                basePower: 1,
                prevBasePower: 1,
                state: states.IDLE,
            };
            board.pos = vec(board.x, board.y + board.y_offset);
            board.pegs = [
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (1 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (3 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (5 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (7 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (9 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (11 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (13 / 8), board.radius / 3),
                vec(board.pos.x, board.pos.y).addWithAngle(PI * (15 / 8), board.radius / 3),
            ];
            discs = [];
        }

        function update() {
            if (!ticks) {
                initializeGame();
            }

            drawBoard();

            if (shooter.state == states.IDLE && input.isJustPressed) {
                shooter.state = states.SHOOTING;
            }

            if (shooter.state == states.SHOOTING) {
                updateShooting();
            }

            if (shooter.state == states.IDLE || shooter.state == states.SHOOTING) {
                drawShooter();
            }
            updateDiscs();
            updatePegs();
        }

        function drawBoard() {
            color("light_black");

            // draw outer ring
            arc(
                board.pos.x, // x
                board.pos.y, // y
                board.radius, // radius
                board.board_thickness, // thickness
                // Math.PI, // from ang
                // 2 * Math.PI, // to ang
            );

            // draw inner ring
            arc(
                board.pos.x, // x
                board.pos.y, // y
                board.radius * 2 / 3, // radius
                1, // thickness
                // Math.PI, // from ang
                // 2 * Math.PI, // to ang
            );

            // draw divider lines
            line(board.pos.x + 4, board.pos.y, board.pos.x + board.radius, board.pos.y, 0.5);
            line(board.pos.x - 4, board.pos.y, board.pos.x - board.radius, board.pos.y, 0.5);
            line(board.pos.x, board.pos.y + 4, board.pos.x, board.pos.y + board.radius, 0.5);
            line(board.pos.x, board.pos.y - 4, board.pos.x, board.pos.y - board.radius, 0.5);


            // draw inner circle / pegs
            // arc(
            //     board.pos.x,
            //     board.pos.y,
            //     board.radius / 3,
            //     1,
            // );

            color("black");
            arc(board.pos, 3.5, 0.5);
            // char("b", board.pos.x - 1, board.pos.y - 1);
            // box(board.pos.x + (board.radius / 3), board.pos.y - (board.radius / 3), 1);
        }

        function updatePegs() {
            color("black");
            board.pegs.forEach(p => {
                // char("c", p);
                rect(p, 1);
                // arc(p, .75, .75);
            });
        }

        function drawShooter() {
            color("black");
            char("a", shooter.pos);
            // box(shooter, 3);
        }

        function updateShooting() {
            // shooter.angle += shooter.angleVel * 0.05;
            shooter.angle = input.pos.angleTo(shooter.pos);
            shooter.power = clamp(input.pos.distanceTo(shooter.pos) / 5 + 0.5, 0.5, 6);
            //     -PI / 2 - PI / 3,
            //     -PI / 2 + PI / 3,
            // );
            // if (
            //     (shooter.angle < -PI && shooter.angleVel < 0) ||
            //     (shooter.angle > 0 && shooter.angleVel > 0)
            // ) {
            //     shooter.angleVel = -shooter.angleVel;
            //     shooter.angle += shooter.angleVel * 0.05 * 2;
            // }
            color("light_blue");
            bar(shooter.pos.x + 1, shooter.pos.y + 1, shooter.power * 5, 1, shooter.angle, 0);

            if (input.isJustReleased) {
                shooter.state = states.JUST_SHOT;
                play("jump");
                discs.push({
                    pos: vec(shooter.pos.x, shooter.pos.y),
                    prevPos: vec(shooter.pos.x, shooter.pos.y),
                    vel: vec(shooter.vel.x, shooter.vel.y).addWithAngle(shooter.angle, shooter.power * 0.5 * shooter.basePower),
                    state: states.MOVING,
                    just_shot: true,
                });
            }
            // line(vec(shooter.pos.x + 1, shooter.pos.y + 1), vec(shooter.pos).addWithAngle(shooter.angle, 12), 1);
        }

        function resetShooter() {
            shooter.pos = shooter.base_pos;
            shooter.state = states.IDLE;
        }

        function updateDiscs() {
            color("black");

            // check if out of bounds
            remove(discs, (d) => {
                if (d.pos.distanceTo(board.pos) > (board.radius + 1)) {
                    if (d.just_shot) {
                        d.just_shot = false;
                        resetShooter();
                    }
                    play("synth");
                    return true;
                }
                char("a", d.pos);

                if (d.vel.length < 0.01) {
                    d.vel = vec(0, 0);
                    d.state = states.IDLE;
                    if (d.just_shot) {
                        d.just_shot = false;
                        resetShooter();
                    }
                } else {
                    // move steps based on velocity
                    let xsteps = abs(d.vel.x);
                    let ysteps = abs(d.vel.y);
                    for (i = 0; i < xsteps; i++) {
                        step = floor(i, 1) * Math.sign(d.vel.x);
                    }
                    d.pos.add(d.vel);
                    d.vel.mul(friction);

                    // console.log(d.vel);
                    // check collisions with pegs
                    board.pegs.forEach((p) => {
                        const checkVec = vec(d.pos);
                        if (checkVec.distanceTo(p) < 4) {
                            checkPegCollide(d, p);
                        }
                    });

                    if (d.state == states.MOVING) {
                        // check collisions with other discs
                        discs.forEach((cd) => {
                            if (d == cd) {
                                return;
                            }

                            if (d.pos.distanceTo(cd.pos) < 4) {
                                const v = vec(d.vel);
                                addCollidingVelocity(d, cd, v);
                                cd.state = states.MOVING;
                                play("hit");
                            }

                        });

                    }

                }

                d.prevPos = vec(d.pos);

            })
        }

        function checkPegCollide(d, p) {
            let hit = false;
            if (d.prevPos.distanceTo(p) < d.pos.distanceTo(p)) {
                return
            }
            console.log(d.pos.distanceTo(p));
            if (abs(p.x - d.pos.x) < 1 && d.vel.y < 0 && p.y < d.pos.y || d.vel.y > 0 && p.y > d.pos.y) {
                d.vel.y *= -1
                hit = true;
            }
            if (abs(p.y - d.pos.y) < 1 && d.vel.x < 0 && p.x < d.pos.x || d.vel.x > 0 && p.x > d.pos.x) {
                d.vel.x *= -1
                hit = true;
            }
            if (hit) {
                play("hit");
            }
        }

        function addCollidingVelocity(d, cd, v) {
            const newAngle = d.pos.angleTo(cd.pos);
            const pr = abs(cos(v.angle - newAngle));
            cd.vel.addWithAngle(newAngle, v.length * pr);
            d.vel.addWithAngle(newAngle, -v.length * pr);
        }

        addEventListener("load", onLoad);
    </script>
</head>

<body style="background: #ddd"></body>

</html>